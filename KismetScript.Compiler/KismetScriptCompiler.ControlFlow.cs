using KismetScript.Compiler.Compiler.Exceptions;
using KismetScript.Compiler.Compiler.Context;
using KismetScript.Syntax;
using KismetScript.Syntax.Statements;
using KismetScript.Syntax.Statements.Declarations;
using KismetScript.Syntax.Statements.Expressions;
using KismetScript.Syntax.Statements.Expressions.Identifiers;
using KismetScript.Syntax.Statements.Expressions.Literals;

namespace KismetScript.Compiler.Compiler;

/// <summary>
/// Partial class containing label management, code offset tracking, and control flow helpers.
/// </summary>
public partial class KismetScriptCompiler
{
    /// <summary>
    /// Creates a compiler label symbol for the current function.
    /// </summary>
    /// <param name="name"></param>
    /// <returns></returns>
    private LabelSymbol CreateCompilerLabel(string name)
    {
        return new LabelSymbol(null)
        {
            CodeOffset = null,
            IsResolved = false,
            Name = name,
            IsExternal = false,
            DeclaringSymbol = _functionContext.Symbol,
        };
    }

    /// <summary>
    /// Resolves the code offset for a label.
    /// </summary>
    /// <param name="labelInfo"></param>
    private void ResolveLabel(LabelSymbol labelInfo)
    {
        labelInfo.IsResolved = true;
        labelInfo.CodeOffset = _functionContext.CodeOffset;
    }

    /// <summary>
    /// Tries to get the label associated with the expression.
    /// </summary>
    /// <param name="expression"></param>
    /// <param name="label"></param>
    /// <returns></returns>
    private bool TryGetLabel(Expression expression, out LabelSymbol label)
    {
        if (expression is IntLiteral literal)
        {
            // TODO fix properly
            label = new LabelSymbol(null)
            {
                DeclaringSymbol = null,
                IsExternal = false,
                Name = $"_{literal.Value}",
                CodeOffset = literal.Value,
                IsResolved = true,
            };
            return true;
        }
        else if (expression is Identifier identifier)
        {
            label = GetSymbol<LabelSymbol>(identifier.Text);
            if (label != null)
            {
                return true;
            }

            // Try to parse symbolic label names like "FunctionName_Offset" or "FunctionName_Offset_CallingFunction"
            // These are generated by the decompiler's FormatCodeOffset method
            var parts = identifier.Text.Split('_');
            if (parts.Length >= 2)
            {
                // Try to find the offset part (should be a number)
                // The pattern is either "FunctionName_Offset" or "FunctionName_Offset_CallingFunction"
                // So we look for a numeric part
                for (int i = parts.Length - 1; i >= 0; i--)
                {
                    if (int.TryParse(parts[i], out var offset))
                    {
                        // Found a numeric offset - create a label for it
                        label = new LabelSymbol(null)
                        {
                            DeclaringSymbol = null,
                            IsExternal = false,
                            Name = identifier.Text,
                            CodeOffset = offset,
                            IsResolved = true,
                        };
                        return true;
                    }
                }
            }
        }

        label = null;
        return false;
    }

    /// <summary>
    /// Gets a label symbol by expression.
    /// </summary>
    /// <param name="expression"></param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    private LabelSymbol GetLabel(Expression expression)
    {
        if (!TryGetLabel(expression, out var label))
            throw new NotImplementedException();
        return label;
    }

    /// <summary>
    /// Gets a label symbol by argument.
    /// </summary>
    /// <param name="argument"></param>
    /// <returns></returns>
    private LabelSymbol GetLabel(Argument argument)
    {
        return GetLabel(argument.Expression);
    }

    /// <summary>
    /// Gets a label symbol by name.
    /// </summary>
    /// <param name="name"></param>
    /// <returns></returns>
    private LabelSymbol GetLabel(string name)
    {
        var label = GetSymbol<LabelSymbol>(name);
        return label;
    }

    /// <summary>
    /// Gets the code offset associated with the given argument.
    /// </summary>
    /// <param name="argument"></param>
    /// <returns></returns>
    private uint? GetCodeOffset(Argument? argument)
    {
        if (!TryGetCodeOffset(argument, out var codeOffset))
            return null;

        return codeOffset;
    }

    /// <summary>
    /// Tries to get the code offset associated with the given argument.
    /// </summary>
    /// <param name="argument"></param>
    /// <param name="codeOffset"></param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    private bool TryGetCodeOffset(Argument? argument, out uint codeOffset)
    {
        if (argument == null)
        {
            codeOffset = 0;
            return false;
        }
        if (argument.Expression is IntLiteral intLiteral)
        {
            codeOffset = (uint)intLiteral.Value;
            return true;
        }
        else if (argument.Expression is Identifier identifier)
        {
            var label = GetLabel(identifier.Text);
            if (!label.IsResolved)
            {
                codeOffset = 0;
                return false;
            }
            else
            {
                codeOffset = (uint)label.CodeOffset;
                return true;
            }
        }
        else
        {
            throw new NotImplementedException();
        }
    }
}
